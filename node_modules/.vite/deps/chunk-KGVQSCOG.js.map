{
  "version": 3,
  "sources": ["../../.pnpm/nuqs@2.4.1_react-router@7.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1/node_modules/nuqs/dist/chunk-5WWTJYGR.js", "../../.pnpm/mitt@3.0.1/node_modules/mitt/src/index.ts"],
  "sourcesContent": ["import { createContext, createElement, useContext } from 'react';\n\n// src/errors.ts\nvar errors = {\n  303: \"Multiple adapter contexts detected. This might happen in monorepos.\",\n  404: \"nuqs requires an adapter to work with your framework.\",\n  409: \"Multiple versions of the library are loaded. This may lead to unexpected behavior. Currently using `%s`, but `%s` (via the %s adapter) was about to load on top.\",\n  414: \"Max safe URL length exceeded. Some browsers may not be able to accept this URL. Consider limiting the amount of state stored in the URL.\",\n  429: \"URL update rate-limited by the browser. Consider increasing `throttleMs` for key(s) `%s`. %O\",\n  500: \"Empty search params cache. Search params can't be accessed in Layouts.\",\n  501: \"Search params cache already populated. Have you called `parse` twice?\"\n};\nfunction error(code) {\n  return `[nuqs] ${errors[code]}\n  See https://err.47ng.com/NUQS-${code}`;\n}\n\n// src/url-encoding.ts\nfunction renderQueryString(search) {\n  if (search.size === 0) {\n    return \"\";\n  }\n  const query = [];\n  for (const [key, value] of search.entries()) {\n    const safeKey = key.replace(/#/g, \"%23\").replace(/&/g, \"%26\").replace(/\\+/g, \"%2B\").replace(/=/g, \"%3D\").replace(/\\?/g, \"%3F\");\n    query.push(`${safeKey}=${encodeQueryValue(value)}`);\n  }\n  const queryString = \"?\" + query.join(\"&\");\n  warnIfURLIsTooLong(queryString);\n  return queryString;\n}\nfunction encodeQueryValue(input) {\n  return input.replace(/%/g, \"%25\").replace(/\\+/g, \"%2B\").replace(/ /g, \"+\").replace(/#/g, \"%23\").replace(/&/g, \"%26\").replace(/\"/g, \"%22\").replace(/'/g, \"%27\").replace(/`/g, \"%60\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/[\\x00-\\x1F]/g, (char) => encodeURIComponent(char));\n}\nvar URL_MAX_LENGTH = 2e3;\nfunction warnIfURLIsTooLong(queryString) {\n  if (process.env.NODE_ENV === \"production\") {\n    return;\n  }\n  if (typeof location === \"undefined\") {\n    return;\n  }\n  const url = new URL(location.href);\n  url.search = queryString;\n  if (url.href.length > URL_MAX_LENGTH) {\n    console.warn(error(414));\n  }\n}\n\n// src/debug.ts\nvar debugEnabled = isDebugEnabled();\nfunction debug(message, ...args) {\n  if (!debugEnabled) {\n    return;\n  }\n  const msg = sprintf(message, ...args);\n  performance.mark(msg);\n  try {\n    console.log(message, ...args);\n  } catch (error2) {\n    console.log(msg);\n  }\n}\nfunction warn(message, ...args) {\n  if (!debugEnabled) {\n    return;\n  }\n  console.warn(message, ...args);\n}\nfunction sprintf(base, ...args) {\n  return base.replace(/%[sfdO]/g, (match) => {\n    const arg = args.shift();\n    if (match === \"%O\" && arg) {\n      return JSON.stringify(arg).replace(/\"([^\"]+)\":/g, \"$1:\");\n    } else {\n      return String(arg);\n    }\n  });\n}\nfunction isDebugEnabled() {\n  try {\n    if (typeof localStorage === \"undefined\") {\n      return false;\n    }\n    const test = \"nuqs-localStorage-test\";\n    localStorage.setItem(test, test);\n    const isStorageAvailable = localStorage.getItem(test) === test;\n    localStorage.removeItem(test);\n    if (!isStorageAvailable) {\n      return false;\n    }\n  } catch (error2) {\n    console.error(\n      \"[nuqs]: debug mode is disabled (localStorage unavailable).\",\n      error2\n    );\n    return false;\n  }\n  const debug2 = localStorage.getItem(\"debug\") ?? \"\";\n  return debug2.includes(\"nuqs\");\n}\n\n// src/adapters/lib/context.ts\nvar context = createContext({\n  useAdapter() {\n    throw new Error(error(404));\n  }\n});\ncontext.displayName = \"NuqsAdapterContext\";\nif (debugEnabled && typeof window !== \"undefined\") {\n  if (window.__NuqsAdapterContext && window.__NuqsAdapterContext !== context) {\n    console.error(error(303));\n  }\n  window.__NuqsAdapterContext = context;\n}\nfunction createAdapterProvider(useAdapter2) {\n  return ({ children, ...props }) => createElement(\n    context.Provider,\n    { ...props, value: { useAdapter: useAdapter2 } },\n    children\n  );\n}\nfunction useAdapter() {\n  const value = useContext(context);\n  if (!(\"useAdapter\" in value)) {\n    throw new Error(error(404));\n  }\n  return value.useAdapter();\n}\n\nexport { context, createAdapterProvider, debug, error, renderQueryString, useAdapter, warn };\n", "export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (\n\ttype: keyof T,\n\tevent: T[keyof T]\n) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<\n\tWildcardHandler<T>\n>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n\tkeyof Events | '*',\n\tEventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n\tall: EventHandlerMap<Events>;\n\n\ton<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n\ton(type: '*', handler: WildcardHandler<Events>): void;\n\n\toff<Key extends keyof Events>(\n\t\ttype: Key,\n\t\thandler?: Handler<Events[Key]>\n\t): void;\n\toff(type: '*', handler: WildcardHandler<Events>): void;\n\n\temit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n\temit<Key extends keyof Events>(\n\t\ttype: undefined extends Events[Key] ? Key : never\n\t): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n\tall?: EventHandlerMap<Events>\n): Emitter<Events> {\n\ttype GenericEventHandler =\n\t\t| Handler<Events[keyof Events]>\n\t\t| WildcardHandler<Events>;\n\tall = all || new Map();\n\n\treturn {\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.push(handler);\n\t\t\t} else {\n\t\t\t\tall!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * If `handler` is omitted, all handlers of the given type are removed.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n\t\t * @param {Function} [handler] Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\tif (handler) {\n\t\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t\t} else {\n\t\t\t\t\tall!.set(type, []);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `'*'` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing '*' handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n\t\t\tlet handlers = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as EventHandlerList<Events[keyof Events]>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(evt!);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\thandlers = all!.get('*');\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as WildCardEventHandlerList<Events>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(type, evt!);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n"],
  "mappings": "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",
  "names": ["all", "Map", "on", "type", "handler", "handlers", "get", "push", "set", "off", "splice", "indexOf", "emit", "evt", "slice", "map"]
}
